# å®‰å…¨æ¼æ´ä¿®å¤æ–¹æ¡ˆ

## ğŸ”´ é«˜å±æ¼æ´ä¿®å¤

### C-01: æ—¶é—´é”ç»•è¿‡é£é™©ä¿®å¤

**åŸå§‹ä»£ç é—®é¢˜**:
```solidity
function scheduleMint(address to, uint256 amount) external onlyRole(MINTER_ROLE) {
    bytes32 actionHash = keccak256(abi.encode("mint", to, amount, block.timestamp));
    // æ½œåœ¨çš„å“ˆå¸Œç¢°æ’é£é™©
}
```

**ä¿®å¤æ–¹æ¡ˆ**:
```solidity
// æ·»åŠ åˆ° SMToken.sol åˆçº¦ä¸­
uint256 private _actionNonce;

function scheduleMint(address to, uint256 amount)
    external
    onlyRole(MINTER_ROLE)
    returns (bytes32)
{
    if (to == address(0)) revert MintToZeroAddress();
    if (amount == 0) revert MintAmountMustBeGreaterThanZero();
    if (mintedAmount + amount > mintingCap) revert ExceedsMintingCap();

    // ä½¿ç”¨ nonce é˜²æ­¢å“ˆå¸Œç¢°æ’
    bytes32 actionHash = keccak256(abi.encode(
        "mint", 
        to, 
        amount, 
        block.timestamp, 
        ++_actionNonce,
        block.number  // é¢å¤–çš„éšæœºæ€§
    ));

    // æ£€æŸ¥æ“ä½œæ˜¯å¦å·²å­˜åœ¨
    if (timelockActions[actionHash].scheduledTime != 0) {
        revert ActionAlreadyScheduled();
    }

    uint64 scheduledTime = uint64(block.timestamp + TIMELOCK_DELAY);
    timelockActions[actionHash].scheduledTime = scheduledTime;

    emit TimelockActionEvent(actionHash, 0, scheduledTime);
    return actionHash;
}

// æ·»åŠ æ–°çš„é”™è¯¯å®šä¹‰
error ActionAlreadyScheduled();
```

### C-02: ä»·æ ¼æ“çºµé£é™©ä¿®å¤

**åŸå§‹ä»£ç é—®é¢˜**:
```solidity
function exchangeTokens() external payable {
    uint256 tokenAmount = (msg.value << 18) / price;
    // ç¼ºå°‘æ»‘ç‚¹ä¿æŠ¤
}
```

**ä¿®å¤æ–¹æ¡ˆ**:
```solidity
// ä¿®æ”¹ SMTokenExchange.sol ä¸­çš„ exchangeTokens å‡½æ•°
function exchangeTokens(uint256 minTokenAmount)
    external
    payable
    nonReentrant
    whenNotPaused
{
    // 1. æ£€æŸ¥é˜¶æ®µ - éªŒè¯æ‰€æœ‰æ¡ä»¶
    if (!exchangeActive) revert ExchangeNotActive();
    if (msg.value < minPurchaseAmount) revert AmountBelowMinimum();
    if (msg.value > maxPurchaseAmount) revert AmountAboveMaximum();

    // ä½¿ç”¨å±€éƒ¨å˜é‡ç¼“å­˜çŠ¶æ€å˜é‡ï¼Œå‡å°‘SLOADæ“ä½œ
    uint8 round = currentRound;
    uint128 price = rounds[round].price;

    if (price == 0) revert PriceNotSet();

    // è®¡ç®—ä»£å¸æ•°é‡
    uint256 tokenAmount = (msg.value * 1e18) / price;
    
    // æ»‘ç‚¹ä¿æŠ¤
    if (tokenAmount < minTokenAmount) revert SlippageTooHigh();

    // æ£€æŸ¥æœ€å¤§å•ç¬”è´­ä¹°é™åˆ¶
    if (tokenAmount > maxTokensPerTransaction) revert ExceedsMaxTokensPerTransaction();

    // ç¼“å­˜çŠ¶æ€å˜é‡
    uint128 tokensSold = totalTokensSold;
    uint128 newTokensSold = tokensSold + uint128(tokenAmount);

    // ç¡®ä¿æœ‰è¶³å¤Ÿçš„ä»£å¸å¯ä¾›å‡ºå”®
    if (newTokensSold > totalTokensForSale) revert NotEnoughTokensLeft();

    // 2. æ•ˆæœé˜¶æ®µ - æ›´æ–°çŠ¶æ€
    totalTokensSold = newTokensSold;
    
    // æ›´æ–°ç”¨æˆ·æ•°æ®
    UserData storage userData = users[msg.sender];
    userData.totalPurchased += uint128(tokenAmount);
    userData.lastPurchaseTime = uint64(block.timestamp);

    // 3. äº¤äº’é˜¶æ®µ - å¤–éƒ¨è°ƒç”¨
    bool success = token.transfer(msg.sender, tokenAmount);
    if (!success) revert TokenTransferFailed();

    // å‘å‡ºäº‹ä»¶
    emit TokensExchanged(msg.sender, msg.value, tokenAmount, block.timestamp, round, price);
}

// æ·»åŠ æ–°çš„çŠ¶æ€å˜é‡
uint256 public maxTokensPerTransaction = 1000000 * 1e18; // 100ä¸‡ä»£å¸ä¸Šé™

// æ·»åŠ æ–°çš„é”™è¯¯å®šä¹‰
error SlippageTooHigh();
error ExceedsMaxTokensPerTransaction();
```

## ğŸŸ¡ ä¸­å±æ¼æ´ä¿®å¤

### M-01: é‡å…¥æ”»å‡»é˜²æŠ¤å®Œå–„

**ä¿®å¤æ–¹æ¡ˆ**:
```solidity
// åœ¨ SMTokenExchange.sol ä¸­æ·»åŠ æ›´ä¸¥æ ¼çš„é‡å…¥ä¿æŠ¤
mapping(address => bool) private _exchanging;

modifier noReentrantExchange() {
    require(!_exchanging[msg.sender], "Exchange in progress");
    _exchanging[msg.sender] = true;
    _;
    _exchanging[msg.sender] = false;
}

function exchangeTokens(uint256 minTokenAmount)
    external
    payable
    nonReentrant
    noReentrantExchange
    whenNotPaused
{
    // å‡½æ•°å®ç°...
}
```

### M-02: è®¿é—®æ§åˆ¶å»ä¸­å¿ƒåŒ–

**ä¿®å¤æ–¹æ¡ˆ**:
```solidity
// æ·»åŠ åˆ° SMToken.sol
contract SMTokenMultiSig {
    uint256 public constant REQUIRED_CONFIRMATIONS = 3;
    uint256 public constant MIN_OWNERS = 3;
    
    address[] public owners;
    mapping(address => bool) public isOwner;
    mapping(bytes32 => mapping(address => bool)) public confirmations;
    mapping(bytes32 => uint256) public confirmationCount;
    
    struct Transaction {
        address target;
        bytes data;
        bool executed;
        uint256 timestamp;
    }
    
    mapping(bytes32 => Transaction) public transactions;
    
    modifier onlyOwner() {
        require(isOwner[msg.sender], "Not an owner");
        _;
    }
    
    function submitTransaction(address target, bytes memory data) 
        external 
        onlyOwner 
        returns (bytes32) 
    {
        bytes32 txHash = keccak256(abi.encode(target, data, block.timestamp));
        transactions[txHash] = Transaction({
            target: target,
            data: data,
            executed: false,
            timestamp: block.timestamp
        });
        
        confirmTransaction(txHash);
        return txHash;
    }
    
    function confirmTransaction(bytes32 txHash) public onlyOwner {
        require(!confirmations[txHash][msg.sender], "Already confirmed");
        
        confirmations[txHash][msg.sender] = true;
        confirmationCount[txHash]++;
        
        if (confirmationCount[txHash] >= REQUIRED_CONFIRMATIONS) {
            executeTransaction(txHash);
        }
    }
    
    function executeTransaction(bytes32 txHash) internal {
        Transaction storage txn = transactions[txHash];
        require(!txn.executed, "Already executed");
        require(confirmationCount[txHash] >= REQUIRED_CONFIRMATIONS, "Not enough confirmations");
        
        txn.executed = true;
        (bool success,) = txn.target.call(txn.data);
        require(success, "Transaction failed");
    }
}
```

### M-03: ä»·æ ¼æ›´æ–°éªŒè¯

**ä¿®å¤æ–¹æ¡ˆ**:
```solidity
// æ·»åŠ åˆ° SMTokenExchange.sol
uint256 public constant MAX_PRICE_CHANGE_PERCENT = 1000; // 10%
uint256 public constant PRICE_UPDATE_COOLDOWN = 1 hours;
uint256 public lastPriceUpdateTime;

function updateRoundPrice(uint8 roundIndex, uint128 newPrice)
    external
    onlyRole(ADMIN_ROLE)
{
    require(roundIndex < MAX_ROUNDS, "Invalid round");
    require(newPrice > 0, "Price must be greater than zero");
    require(
        block.timestamp >= lastPriceUpdateTime + PRICE_UPDATE_COOLDOWN,
        "Price update cooldown not met"
    );

    uint128 currentPrice = rounds[roundIndex].price;
    
    // éªŒè¯ä»·æ ¼å˜åŒ–å¹…åº¦
    if (currentPrice > 0) {
        uint256 priceChange = newPrice > currentPrice 
            ? ((newPrice - currentPrice) * 10000) / currentPrice
            : ((currentPrice - newPrice) * 10000) / currentPrice;
            
        require(
            priceChange <= MAX_PRICE_CHANGE_PERCENT,
            "Price change exceeds maximum allowed"
        );
    }

    // éªŒè¯ä»·æ ¼åˆç†æ€§ï¼ˆä¸å¸‚åœºä»·æ ¼å¯¹æ¯”ï¼‰
    int256 marketPrice = getMarketPrice();
    require(marketPrice > 0, "Invalid market price");
    
    uint256 deviation = uint256(marketPrice) > newPrice
        ? ((uint256(marketPrice) - newPrice) * 10000) / uint256(marketPrice)
        : ((newPrice - uint256(marketPrice)) * 10000) / uint256(marketPrice);
        
    require(deviation <= 2000, "Price deviates too much from market"); // 20% max deviation

    rounds[roundIndex].price = newPrice;
    lastPriceUpdateTime = block.timestamp;
    
    emit PriceUpdated(roundIndex, currentPrice, newPrice, block.timestamp);
}

function getMarketPrice() internal view returns (int256) {
    // ä½¿ç”¨ Chainlink ä»·æ ¼é¢„è¨€æœºè·å–å¸‚åœºä»·æ ¼
    if (address(bnbPriceFeed) != address(0)) {
        (, int256 price, , , ) = bnbPriceFeed.latestRoundData();
        return price;
    }
    return 0;
}

event PriceUpdated(uint8 indexed round, uint128 oldPrice, uint128 newPrice, uint256 timestamp);
```

### M-04: ç´§æ€¥æš‚åœæœºåˆ¶å®Œå–„

**ä¿®å¤æ–¹æ¡ˆ**:
```solidity
// æ·»åŠ åˆ°ä¸¤ä¸ªåˆçº¦ä¸­
uint256 public constant MAX_PAUSE_DURATION = 7 days;
uint256 public pauseStartTime;
bool public emergencyPauseActive;

function emergencyPause() external onlyRole(PAUSER_ROLE) {
    require(!emergencyPauseActive, "Emergency pause already active");
    
    pauseStartTime = block.timestamp;
    emergencyPauseActive = true;
    _pause();
    
    emit EmergencyPauseActivated(msg.sender, block.timestamp);
}

function emergencyUnpause() external onlyRole(PAUSER_ROLE) {
    require(emergencyPauseActive, "Emergency pause not active");
    
    emergencyPauseActive = false;
    _unpause();
    
    emit EmergencyPauseDeactivated(msg.sender, block.timestamp);
}

function checkPauseExpiry() external {
    if (emergencyPauseActive && 
        block.timestamp > pauseStartTime + MAX_PAUSE_DURATION) {
        
        emergencyPauseActive = false;
        _unpause();
        
        emit EmergencyPauseExpired(block.timestamp);
    }
}

// è‡ªåŠ¨æ£€æŸ¥æš‚åœè¿‡æœŸï¼ˆåœ¨å…³é”®å‡½æ•°ä¸­è°ƒç”¨ï¼‰
modifier checkEmergencyPause() {
    if (emergencyPauseActive && 
        block.timestamp > pauseStartTime + MAX_PAUSE_DURATION) {
        emergencyPauseActive = false;
        _unpause();
        emit EmergencyPauseExpired(block.timestamp);
    }
    _;
}

event EmergencyPauseActivated(address indexed pauser, uint256 timestamp);
event EmergencyPauseDeactivated(address indexed pauser, uint256 timestamp);
event EmergencyPauseExpired(uint256 timestamp);
```

## ğŸ”µ ä½å±é—®é¢˜ä¿®å¤

### L-01: Gas ä¼˜åŒ–

**ä¿®å¤æ–¹æ¡ˆ**:
```solidity
// ä½¿ç”¨ packed structs ä¼˜åŒ–å­˜å‚¨
struct OptimizedUserData {
    uint128 totalPurchased;    // 16 bytes
    uint64 lastPurchaseTime;   // 8 bytes
    uint32 purchaseCount;      // 4 bytes
    bool isVerified;           // 1 byte
    // æ€»è®¡: 29 bytesï¼Œå¯ä»¥æ”¾åœ¨ä¸€ä¸ªå­˜å‚¨æ§½ä¸­
}

// ä½¿ç”¨ä½æ“ä½œä¼˜åŒ–è®¡ç®—
function calculateTokenAmount(uint256 bnbAmount, uint256 price) 
    internal 
    pure 
    returns (uint256) 
{
    // ä½¿ç”¨ä½ç§»ä»£æ›¿ä¹˜æ³•ï¼ˆå½“å¯èƒ½æ—¶ï¼‰
    return (bnbAmount << 18) / price;
}

// æ‰¹é‡æ“ä½œä¼˜åŒ–
function batchTransfer(address[] calldata recipients, uint256[] calldata amounts)
    external
    onlyRole(MINTER_ROLE)
{
    require(recipients.length == amounts.length, "Array length mismatch");
    
    uint256 totalAmount = 0;
    for (uint256 i = 0; i < amounts.length; i++) {
        totalAmount += amounts[i];
    }
    
    require(mintedAmount + totalAmount <= mintingCap, "Exceeds minting cap");
    
    for (uint256 i = 0; i < recipients.length; i++) {
        _mint(recipients[i], amounts[i]);
    }
    
    mintedAmount += totalAmount;
}
```

### L-02: å®Œå–„äº‹ä»¶æ—¥å¿—

**ä¿®å¤æ–¹æ¡ˆ**:
```solidity
// æ·»åŠ è¯¦ç»†çš„äº‹ä»¶å®šä¹‰
event DetailedTokensExchanged(
    address indexed buyer,
    uint256 bnbAmount,
    uint256 tokenAmount,
    uint256 timestamp,
    uint8 round,
    uint256 price,
    uint256 totalTokensSold,
    uint256 userTotalPurchased
);

event SecurityEvent(
    string indexed eventType,
    address indexed user,
    uint256 amount,
    uint256 timestamp,
    bytes32 indexed transactionHash
);

event AdminAction(
    string indexed actionType,
    address indexed admin,
    bytes data,
    uint256 timestamp
);

// åœ¨ç›¸å…³å‡½æ•°ä¸­å‘å‡ºè¯¦ç»†äº‹ä»¶
function exchangeTokens(uint256 minTokenAmount) external payable {
    // ... å‡½æ•°é€»è¾‘ ...
    
    emit DetailedTokensExchanged(
        msg.sender,
        msg.value,
        tokenAmount,
        block.timestamp,
        currentRound,
        rounds[currentRound].price,
        totalTokensSold,
        users[msg.sender].totalPurchased
    );
    
    emit SecurityEvent(
        "TOKEN_EXCHANGE",
        msg.sender,
        tokenAmount,
        block.timestamp,
        keccak256(abi.encode(msg.sender, msg.value, block.timestamp))
    );
}
```

## ğŸ“‹ ä¿®å¤éªŒè¯æ¸…å•

### é«˜å±æ¼æ´ä¿®å¤éªŒè¯
- [ ] C-01: æ—¶é—´é”å“ˆå¸Œç¢°æ’å·²ä¿®å¤
- [ ] C-02: æ»‘ç‚¹ä¿æŠ¤å·²å®ç°

### ä¸­å±æ¼æ´ä¿®å¤éªŒè¯
- [ ] M-01: é‡å…¥æ”»å‡»é˜²æŠ¤å·²åŠ å¼º
- [ ] M-02: å¤šç­¾æœºåˆ¶å·²å®ç°
- [ ] M-03: ä»·æ ¼éªŒè¯å·²æ·»åŠ 
- [ ] M-04: æš‚åœæœºåˆ¶å·²å®Œå–„

### ä½å±é—®é¢˜ä¿®å¤éªŒè¯
- [ ] L-01: Gas ä¼˜åŒ–å·²å®ç°
- [ ] L-02: äº‹ä»¶æ—¥å¿—å·²å®Œå–„
- [ ] L-03: é”™è¯¯æ¶ˆæ¯å·²è¯¦ç»†åŒ–
- [ ] L-04: æ—¶é—´æˆ³ä¾èµ–å·²å‡å°‘
- [ ] L-05: æº¢å‡ºæ£€æŸ¥å·²æ·»åŠ 
- [ ] L-06: å‡çº§æ§åˆ¶å·²åŠ å¼º

## ğŸ§ª æµ‹è¯•å»ºè®®

### å•å…ƒæµ‹è¯•
```solidity
// æµ‹è¯•æ—¶é—´é”å“ˆå¸Œç¢°æ’ä¿®å¤
function testScheduleMintNonceIncrement() public {
    bytes32 hash1 = smToken.scheduleMint(user1, 1000);
    bytes32 hash2 = smToken.scheduleMint(user1, 1000);
    assertNotEq(hash1, hash2, "Hashes should be different");
}

// æµ‹è¯•æ»‘ç‚¹ä¿æŠ¤
function testSlippageProtection() public {
    vm.expectRevert("Slippage too high");
    smTokenExchange.exchangeTokens{value: 1 ether}(2000 ether);
}
```

### é›†æˆæµ‹è¯•
```solidity
// æµ‹è¯•ç´§æ€¥æš‚åœè‡ªåŠ¨è¿‡æœŸ
function testEmergencyPauseExpiry() public {
    smToken.emergencyPause();
    vm.warp(block.timestamp + 8 days);
    smToken.checkPauseExpiry();
    assertFalse(smToken.paused(), "Should be unpaused after expiry");
}
```

---

*æ‰€æœ‰ä¿®å¤æ–¹æ¡ˆéƒ½åº”è¯¥åœ¨æµ‹è¯•ç½‘ä¸Šå……åˆ†æµ‹è¯•åå†éƒ¨ç½²åˆ°ä¸»ç½‘ã€‚*
