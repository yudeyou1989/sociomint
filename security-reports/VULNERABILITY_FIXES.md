# 安全漏洞修复方案

## 🔴 高危漏洞修复

### C-01: 时间锁绕过风险修复

**原始代码问题**:
```solidity
function scheduleMint(address to, uint256 amount) external onlyRole(MINTER_ROLE) {
    bytes32 actionHash = keccak256(abi.encode("mint", to, amount, block.timestamp));
    // 潜在的哈希碰撞风险
}
```

**修复方案**:
```solidity
// 添加到 SMToken.sol 合约中
uint256 private _actionNonce;

function scheduleMint(address to, uint256 amount)
    external
    onlyRole(MINTER_ROLE)
    returns (bytes32)
{
    if (to == address(0)) revert MintToZeroAddress();
    if (amount == 0) revert MintAmountMustBeGreaterThanZero();
    if (mintedAmount + amount > mintingCap) revert ExceedsMintingCap();

    // 使用 nonce 防止哈希碰撞
    bytes32 actionHash = keccak256(abi.encode(
        "mint", 
        to, 
        amount, 
        block.timestamp, 
        ++_actionNonce,
        block.number  // 额外的随机性
    ));

    // 检查操作是否已存在
    if (timelockActions[actionHash].scheduledTime != 0) {
        revert ActionAlreadyScheduled();
    }

    uint64 scheduledTime = uint64(block.timestamp + TIMELOCK_DELAY);
    timelockActions[actionHash].scheduledTime = scheduledTime;

    emit TimelockActionEvent(actionHash, 0, scheduledTime);
    return actionHash;
}

// 添加新的错误定义
error ActionAlreadyScheduled();
```

### C-02: 价格操纵风险修复

**原始代码问题**:
```solidity
function exchangeTokens() external payable {
    uint256 tokenAmount = (msg.value << 18) / price;
    // 缺少滑点保护
}
```

**修复方案**:
```solidity
// 修改 SMTokenExchange.sol 中的 exchangeTokens 函数
function exchangeTokens(uint256 minTokenAmount)
    external
    payable
    nonReentrant
    whenNotPaused
{
    // 1. 检查阶段 - 验证所有条件
    if (!exchangeActive) revert ExchangeNotActive();
    if (msg.value < minPurchaseAmount) revert AmountBelowMinimum();
    if (msg.value > maxPurchaseAmount) revert AmountAboveMaximum();

    // 使用局部变量缓存状态变量，减少SLOAD操作
    uint8 round = currentRound;
    uint128 price = rounds[round].price;

    if (price == 0) revert PriceNotSet();

    // 计算代币数量
    uint256 tokenAmount = (msg.value * 1e18) / price;
    
    // 滑点保护
    if (tokenAmount < minTokenAmount) revert SlippageTooHigh();

    // 检查最大单笔购买限制
    if (tokenAmount > maxTokensPerTransaction) revert ExceedsMaxTokensPerTransaction();

    // 缓存状态变量
    uint128 tokensSold = totalTokensSold;
    uint128 newTokensSold = tokensSold + uint128(tokenAmount);

    // 确保有足够的代币可供出售
    if (newTokensSold > totalTokensForSale) revert NotEnoughTokensLeft();

    // 2. 效果阶段 - 更新状态
    totalTokensSold = newTokensSold;
    
    // 更新用户数据
    UserData storage userData = users[msg.sender];
    userData.totalPurchased += uint128(tokenAmount);
    userData.lastPurchaseTime = uint64(block.timestamp);

    // 3. 交互阶段 - 外部调用
    bool success = token.transfer(msg.sender, tokenAmount);
    if (!success) revert TokenTransferFailed();

    // 发出事件
    emit TokensExchanged(msg.sender, msg.value, tokenAmount, block.timestamp, round, price);
}

// 添加新的状态变量
uint256 public maxTokensPerTransaction = 1000000 * 1e18; // 100万代币上限

// 添加新的错误定义
error SlippageTooHigh();
error ExceedsMaxTokensPerTransaction();
```

## 🟡 中危漏洞修复

### M-01: 重入攻击防护完善

**修复方案**:
```solidity
// 在 SMTokenExchange.sol 中添加更严格的重入保护
mapping(address => bool) private _exchanging;

modifier noReentrantExchange() {
    require(!_exchanging[msg.sender], "Exchange in progress");
    _exchanging[msg.sender] = true;
    _;
    _exchanging[msg.sender] = false;
}

function exchangeTokens(uint256 minTokenAmount)
    external
    payable
    nonReentrant
    noReentrantExchange
    whenNotPaused
{
    // 函数实现...
}
```

### M-02: 访问控制去中心化

**修复方案**:
```solidity
// 添加到 SMToken.sol
contract SMTokenMultiSig {
    uint256 public constant REQUIRED_CONFIRMATIONS = 3;
    uint256 public constant MIN_OWNERS = 3;
    
    address[] public owners;
    mapping(address => bool) public isOwner;
    mapping(bytes32 => mapping(address => bool)) public confirmations;
    mapping(bytes32 => uint256) public confirmationCount;
    
    struct Transaction {
        address target;
        bytes data;
        bool executed;
        uint256 timestamp;
    }
    
    mapping(bytes32 => Transaction) public transactions;
    
    modifier onlyOwner() {
        require(isOwner[msg.sender], "Not an owner");
        _;
    }
    
    function submitTransaction(address target, bytes memory data) 
        external 
        onlyOwner 
        returns (bytes32) 
    {
        bytes32 txHash = keccak256(abi.encode(target, data, block.timestamp));
        transactions[txHash] = Transaction({
            target: target,
            data: data,
            executed: false,
            timestamp: block.timestamp
        });
        
        confirmTransaction(txHash);
        return txHash;
    }
    
    function confirmTransaction(bytes32 txHash) public onlyOwner {
        require(!confirmations[txHash][msg.sender], "Already confirmed");
        
        confirmations[txHash][msg.sender] = true;
        confirmationCount[txHash]++;
        
        if (confirmationCount[txHash] >= REQUIRED_CONFIRMATIONS) {
            executeTransaction(txHash);
        }
    }
    
    function executeTransaction(bytes32 txHash) internal {
        Transaction storage txn = transactions[txHash];
        require(!txn.executed, "Already executed");
        require(confirmationCount[txHash] >= REQUIRED_CONFIRMATIONS, "Not enough confirmations");
        
        txn.executed = true;
        (bool success,) = txn.target.call(txn.data);
        require(success, "Transaction failed");
    }
}
```

### M-03: 价格更新验证

**修复方案**:
```solidity
// 添加到 SMTokenExchange.sol
uint256 public constant MAX_PRICE_CHANGE_PERCENT = 1000; // 10%
uint256 public constant PRICE_UPDATE_COOLDOWN = 1 hours;
uint256 public lastPriceUpdateTime;

function updateRoundPrice(uint8 roundIndex, uint128 newPrice)
    external
    onlyRole(ADMIN_ROLE)
{
    require(roundIndex < MAX_ROUNDS, "Invalid round");
    require(newPrice > 0, "Price must be greater than zero");
    require(
        block.timestamp >= lastPriceUpdateTime + PRICE_UPDATE_COOLDOWN,
        "Price update cooldown not met"
    );

    uint128 currentPrice = rounds[roundIndex].price;
    
    // 验证价格变化幅度
    if (currentPrice > 0) {
        uint256 priceChange = newPrice > currentPrice 
            ? ((newPrice - currentPrice) * 10000) / currentPrice
            : ((currentPrice - newPrice) * 10000) / currentPrice;
            
        require(
            priceChange <= MAX_PRICE_CHANGE_PERCENT,
            "Price change exceeds maximum allowed"
        );
    }

    // 验证价格合理性（与市场价格对比）
    int256 marketPrice = getMarketPrice();
    require(marketPrice > 0, "Invalid market price");
    
    uint256 deviation = uint256(marketPrice) > newPrice
        ? ((uint256(marketPrice) - newPrice) * 10000) / uint256(marketPrice)
        : ((newPrice - uint256(marketPrice)) * 10000) / uint256(marketPrice);
        
    require(deviation <= 2000, "Price deviates too much from market"); // 20% max deviation

    rounds[roundIndex].price = newPrice;
    lastPriceUpdateTime = block.timestamp;
    
    emit PriceUpdated(roundIndex, currentPrice, newPrice, block.timestamp);
}

function getMarketPrice() internal view returns (int256) {
    // 使用 Chainlink 价格预言机获取市场价格
    if (address(bnbPriceFeed) != address(0)) {
        (, int256 price, , , ) = bnbPriceFeed.latestRoundData();
        return price;
    }
    return 0;
}

event PriceUpdated(uint8 indexed round, uint128 oldPrice, uint128 newPrice, uint256 timestamp);
```

### M-04: 紧急暂停机制完善

**修复方案**:
```solidity
// 添加到两个合约中
uint256 public constant MAX_PAUSE_DURATION = 7 days;
uint256 public pauseStartTime;
bool public emergencyPauseActive;

function emergencyPause() external onlyRole(PAUSER_ROLE) {
    require(!emergencyPauseActive, "Emergency pause already active");
    
    pauseStartTime = block.timestamp;
    emergencyPauseActive = true;
    _pause();
    
    emit EmergencyPauseActivated(msg.sender, block.timestamp);
}

function emergencyUnpause() external onlyRole(PAUSER_ROLE) {
    require(emergencyPauseActive, "Emergency pause not active");
    
    emergencyPauseActive = false;
    _unpause();
    
    emit EmergencyPauseDeactivated(msg.sender, block.timestamp);
}

function checkPauseExpiry() external {
    if (emergencyPauseActive && 
        block.timestamp > pauseStartTime + MAX_PAUSE_DURATION) {
        
        emergencyPauseActive = false;
        _unpause();
        
        emit EmergencyPauseExpired(block.timestamp);
    }
}

// 自动检查暂停过期（在关键函数中调用）
modifier checkEmergencyPause() {
    if (emergencyPauseActive && 
        block.timestamp > pauseStartTime + MAX_PAUSE_DURATION) {
        emergencyPauseActive = false;
        _unpause();
        emit EmergencyPauseExpired(block.timestamp);
    }
    _;
}

event EmergencyPauseActivated(address indexed pauser, uint256 timestamp);
event EmergencyPauseDeactivated(address indexed pauser, uint256 timestamp);
event EmergencyPauseExpired(uint256 timestamp);
```

## 🔵 低危问题修复

### L-01: Gas 优化

**修复方案**:
```solidity
// 使用 packed structs 优化存储
struct OptimizedUserData {
    uint128 totalPurchased;    // 16 bytes
    uint64 lastPurchaseTime;   // 8 bytes
    uint32 purchaseCount;      // 4 bytes
    bool isVerified;           // 1 byte
    // 总计: 29 bytes，可以放在一个存储槽中
}

// 使用位操作优化计算
function calculateTokenAmount(uint256 bnbAmount, uint256 price) 
    internal 
    pure 
    returns (uint256) 
{
    // 使用位移代替乘法（当可能时）
    return (bnbAmount << 18) / price;
}

// 批量操作优化
function batchTransfer(address[] calldata recipients, uint256[] calldata amounts)
    external
    onlyRole(MINTER_ROLE)
{
    require(recipients.length == amounts.length, "Array length mismatch");
    
    uint256 totalAmount = 0;
    for (uint256 i = 0; i < amounts.length; i++) {
        totalAmount += amounts[i];
    }
    
    require(mintedAmount + totalAmount <= mintingCap, "Exceeds minting cap");
    
    for (uint256 i = 0; i < recipients.length; i++) {
        _mint(recipients[i], amounts[i]);
    }
    
    mintedAmount += totalAmount;
}
```

### L-02: 完善事件日志

**修复方案**:
```solidity
// 添加详细的事件定义
event DetailedTokensExchanged(
    address indexed buyer,
    uint256 bnbAmount,
    uint256 tokenAmount,
    uint256 timestamp,
    uint8 round,
    uint256 price,
    uint256 totalTokensSold,
    uint256 userTotalPurchased
);

event SecurityEvent(
    string indexed eventType,
    address indexed user,
    uint256 amount,
    uint256 timestamp,
    bytes32 indexed transactionHash
);

event AdminAction(
    string indexed actionType,
    address indexed admin,
    bytes data,
    uint256 timestamp
);

// 在相关函数中发出详细事件
function exchangeTokens(uint256 minTokenAmount) external payable {
    // ... 函数逻辑 ...
    
    emit DetailedTokensExchanged(
        msg.sender,
        msg.value,
        tokenAmount,
        block.timestamp,
        currentRound,
        rounds[currentRound].price,
        totalTokensSold,
        users[msg.sender].totalPurchased
    );
    
    emit SecurityEvent(
        "TOKEN_EXCHANGE",
        msg.sender,
        tokenAmount,
        block.timestamp,
        keccak256(abi.encode(msg.sender, msg.value, block.timestamp))
    );
}
```

## 📋 修复验证清单

### 高危漏洞修复验证
- [ ] C-01: 时间锁哈希碰撞已修复
- [ ] C-02: 滑点保护已实现

### 中危漏洞修复验证
- [ ] M-01: 重入攻击防护已加强
- [ ] M-02: 多签机制已实现
- [ ] M-03: 价格验证已添加
- [ ] M-04: 暂停机制已完善

### 低危问题修复验证
- [ ] L-01: Gas 优化已实现
- [ ] L-02: 事件日志已完善
- [ ] L-03: 错误消息已详细化
- [ ] L-04: 时间戳依赖已减少
- [ ] L-05: 溢出检查已添加
- [ ] L-06: 升级控制已加强

## 🧪 测试建议

### 单元测试
```solidity
// 测试时间锁哈希碰撞修复
function testScheduleMintNonceIncrement() public {
    bytes32 hash1 = smToken.scheduleMint(user1, 1000);
    bytes32 hash2 = smToken.scheduleMint(user1, 1000);
    assertNotEq(hash1, hash2, "Hashes should be different");
}

// 测试滑点保护
function testSlippageProtection() public {
    vm.expectRevert("Slippage too high");
    smTokenExchange.exchangeTokens{value: 1 ether}(2000 ether);
}
```

### 集成测试
```solidity
// 测试紧急暂停自动过期
function testEmergencyPauseExpiry() public {
    smToken.emergencyPause();
    vm.warp(block.timestamp + 8 days);
    smToken.checkPauseExpiry();
    assertFalse(smToken.paused(), "Should be unpaused after expiry");
}
```

---

*所有修复方案都应该在测试网上充分测试后再部署到主网。*
